# ${license-info}
# ${developer-info}
# ${author-info}


package NCM::Component::altlogrotate;

use strict;
use NCM::Component;
use vars qw(@ISA $EC);
@ISA = qw(NCM::Component);
$EC=LC::Exception::Context->new->will_store_all;
use NCM::Check;
use File::Copy;

use EDG::WP4::CCM::Element;


local(*DTA);


##########################################################################
sub Configure($$@) {
##########################################################################
    
    my ($self, $config) = @_;

    my $base = "/software/components/altlogrotate";
    my $cfgfile = $config->getValue("$base/configFile");
    my $cfgdir = $config->getValue("$base/configDir");

    # Ensure that the configuration directory exists. 
    mkpath($cfgdir,0,0755) unless (-e $cfgdir);
    unless (-d $cfgdir) {
	$self->error("$cfgdir directory can't be made or isn't a directory");
    }

    # Collect the current entries in the logrotate.d directory.  NOTE:
    # only those explicitly managed by the component are selected. 
    opendir DIR, $cfgdir;
    my @files = grep /\.ncm-altlogrotate$/, map "$cfgdir/$_", readdir DIR;
    closedir DIR;

    # Actually delete them.  This should always be done as no entries
    # in the machine profile means that there should be no entries in 
    # the directory either. 
    foreach my $to_unlink (@files) {
	# Untainted to_unlink to work with tainted perl mode (-T option)
        if ($to_unlink =~ /^(.*)$/) {
                $to_unlink = $1;                     # $to_unlink is now untainted
        } else {
                $self->error("Bad data in $to_unlink");
        }
        $self->warn("error ($?) deleting file $_") unless (unlink $to_unlink);

	#
	# restore eventually backed up files (to be implemented)
	# Note: this is problematic as new versions of an application
	# may have deployed newer versions of logrotate scripts...

    }

    # Pull out the parameters from the configuration. 
    my %entries = $config->getElement("$base/entries")->getHash();

    # Get the keys in the array.  The 'global' key - if found - is put at the beginning
    my $overallglobal=0;

    my @names = ();
    foreach (sort keys %entries) {
      unless ($_ eq 'global') {
	push @names, $_;
      } else {
	unshift @names, $_;
	$overallglobal=1; # global config file will be re-created
      }
    }

    # Loop through all of the entries and create configuration files.
    foreach my $name (@names) {

        my $element = $entries{$name};
	my %entry = $element->getHash();

	my $global = ($name eq 'global' || 
		      (defined($entry{global}) && 
		       $entry{global}->getValue() eq 'true'));

	if ($global && !$overallglobal) {
	  # global configuration file must be either completely managed, or not managed at all
	  $self->error("setting for '$name' inside global configuration file found, but no entry for global config file defined (below $base/global): setting ignored");
	  next; # ignore this setting
	}

    # Make contents.
	my $contents = "\n#\n# Generated by ncm-altlogrotate.\n#\n";
	$contents = $self->processHash($contents, \%entry);

	my $file = $global ? $cfgfile : "$cfgdir/$name.ncm-altlogrotate";
	my $writetype = ($global && ($name ne 'global')) ? '>>' : '>' ;

	# replace existing legacy logrotate file (if option 'overwrite'==true)?
	if (exists($entry{overwrite}) && defined($entry{overwrite}) && 
	    $entry{overwrite}->getValue() eq 'true' && !$global) {
	  # if $cfgdir/$name does already exist:
	  # remove it and replace it with the CDB configuration
	  if (-e "$cfgdir/$name") {

	    # back up the file (to be implemented)

	    # remove the old file
	    $self->warn("error ($?) deleting file $cfgdir/$name") unless (unlink "$cfgdir/$name");
	    $file = "$cfgdir/$name"; # no .ncm-altlogrotate extension
	  }
	}

	# Write the output file.
	open CONF,"$writetype $file";
	print CONF $contents;
	close CONF;
    }
    return 1;
}

sub processHash {

    my ($self, $contents, $href) = @_;

    my %entry = %$href;

    if (defined($entry{pattern})) {
	$contents .= $entry{pattern}->getValue() . " {\n";
    }

    if (defined($entry{compress})) {
	$contents .= 'no' unless ($entry{compress}->getValue() eq 'true');
	$contents .= "compress\n";
    }
    
    if (defined($entry{copy})) {
	$contents .= 'no' unless ($entry{copy}->getValue() eq 'true');
	$contents .= "copy\n";
    }
    
    if (defined($entry{copytruncate})) {
	$contents .= 'no' unless ($entry{copytruncate}->getValue() eq 'true');
	$contents .= "copytruncate\n";
    }
    
    if (defined($entry{dateext})) {
	$contents .= 'no' unless ($entry{dateext}->getValue() eq 'true');
	$contents .= "dateext\n";
    }
    
    if (defined($entry{delaycompress})) {
	$contents .= 'no' unless ($entry{delaycompress}->getValue() eq 'true');
	$contents .= "delaycompress\n";
    }
    
    if (defined($entry{ifempty})) {
	$contents .= "not" unless ($entry{ifempty}->getValue() eq 'true');
	$contents .= "ifempty\n";
    }
    
    if (defined($entry{missingok})) {
	$contents .= 'no' unless ($entry{missingok}->getValue() eq 'true');
	$contents .= "missingok\n";
    }
    
    if (defined($entry{sharedscripts})) {
	$contents .= 'no' unless ($entry{sharedscripts}->getValue() eq 'true');
	$contents .= "sharedscripts\n";
    }
    
    if (defined($entry{compresscmd})) {
	$contents .= 'compresscmd ' . 
	    $entry{compresscmd}->getValue() . "\n";
    }
    
    if (defined($entry{uncompresscmd})) {
	$contents .= 'uncompresscmd ' . 
	    $entry{uncompresscmd}->getValue() . "\n";
    }
    
    if (defined($entry{compressext})) {
	$contents .= 'compressext ' . 
	    $entry{compressext}->getValue() . "\n";
    }
    
    if (defined($entry{compressoptions})) {
	$contents .= 'compressoptions ' . 
	    $entry{compressoptions}->getValue() . "\n";
    }
    
    if (defined($entry{create})) {
	if ($entry{create}->getValue() eq 'true') {
	    $contents .= 'create ';
	    if (defined($entry{createparams})) {
		my %chash = $entry{createparams}->getHash();
		$contents .= 
		    $chash{mode}->getValue() . ' ' . 
		    $chash{owner}->getValue() . ' ' . 
		    $chash{group}->getValue(); 
	    }
	    $contents .= "\n";
	} else {
	    $contents .= "nocreate\n";
	}
    }
    
    if (defined($entry{extension})) {
	$contents .= 'extension ' . 
	    $entry{extension}->getValue() . "\n";
    }
    
    if (defined($entry{mail})) {
	$contents .= 'mail ' . 
	    $entry{mail}->getValue() . "\n"; 
    }
    
    if (defined($entry{nomail})) {
	$contents .= "nomail\n" unless ($entry{nomail}->getValue() eq 'false');
    }
    
    if (defined($entry{mailselect})) {
	$contents .= 'mail' . 
	    $entry{mailselect}->getValue() . "\n"; 
    }
    
    if (defined($entry{olddir})) {
	$contents .= 'olddir ' . 
	    $entry{olddir}->getValue() . "\n"; 
    }
    
    if (defined($entry{noolddir})) {
	$contents .= "noolddir\n" unless (exists $entry{olddir} && $entry{olddir}->getValue() eq 'true');
    }
    
    if (defined($entry{rotate})) {
	$contents .= 'rotate ' . 
	    $entry{rotate}->getValue() . "\n"; 
    }
    
    if (defined($entry{start})) {
	$contents .= 'start ' . 
	    $entry{start}->getValue() . "\n"; 
    }
    
    if (defined($entry{size})) {
	$contents .= 'size ' . 
	    $entry{size}->getValue() . "\n"; 
    }
    
    if (defined($entry{tabooext})) {
	$contents .= 'tabooext ';
	if (defined($entry{taboo_replace})) {
	    $contents .= '+ ';
	}
	$contents .= $entry{tabooext}->getValue() . "\n"; 
    }
    
    if (defined($entry{frequency})) {
	$contents .=  
	    $entry{frequency}->getValue() . "\n"; 
    }
    
    if (defined($entry{scripts})) {
	my %shash = $entry{scripts}->getHash();
	foreach my $sname (sort keys %shash) {
	    $contents .= "$sname\n\n";
	    $contents .= $shash{$sname}->getValue() . "\n";
	    $contents .= "\nendscript\n";
	} 
    }

    if (defined($entry{include}) && !defined($entry{pattern})) {
	$contents .= 'include ';
	$contents .= $entry{include}->getValue() . "\n";
    }
    
    if (defined($entry{pattern})) {
	$contents .= "}\n";
    }
    
    return $contents;
}


1;      # Required for PERL modules
