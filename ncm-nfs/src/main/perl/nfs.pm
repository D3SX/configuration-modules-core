# ${license-info}
# ${developer-info}
# ${author-info}

package NCM::Component::nfs;

use strict;
use warnings;

use NCM::Component;
use vars qw(@ISA $EC);
@ISA = qw(NCM::Component);
$EC=LC::Exception::Context->new->will_store_all;

use File::Path qw(mkpath);

use Readonly;
# The absolute names of configuration files.
Readonly my $EXPORTS => "/etc/exports";
Readonly my $FSTAB => "/etc/fstab";

# Compares two NFS entries for equality.  If equal, then
# 0 is returned.  If the entries differ in the devices or
# mountpoint, then 1 is returned.  Otherwise, 2 is returned.
# This is a function, not a method.
sub compare_entries
{
    my ($nref, $oref) = @_;

    # Can numeric 'A != B' be different than 'A ne B' ?
    my $ne = sub {
        my $attr = shift;
        return $nref->{$attr} ne $oref->{$attr};
    };

    return 1 if (&$ne('device') || &$ne('mntpt'));
    return 2 if (&$ne('fstype') || &$ne('opt') ||
                 &$ne('freq') || &$ne('passno'));

    # Got the end, so hashes must be equal.
    return 0;
}


sub exports
{
    my ($self, $nfs_config) = @_;

    # Collect information for exports file.
    my $contents .= "#\n# File generated by ncm-nfs on " .
        localtime() . ".\n#\n";


    # Process exports to build /etc/exports #

    if ($nfs_config->{'exports'}) {

        # Pull out the parameters from the configuration.
        my $exports = $nfs_config->{'exports'};

        # Loop through all of the servers creating a line for each.
        for my $entry (@{$exports}) {
            my $path = $entry->{'path'};
            my $hosts = $entry->{'hosts'};

            my @entries;
            for my $host_e (keys(%{$hosts}) ) {
                my $host = unescape($host_e);
                my $export_opts = $hosts->{$host_e};
                # add option 'sync if neither 'sync', nor 'async' has been specified
                if ( $export_opts !~ m/sync/ ) {
                    if ( length($export_opts) > 0 ) {
                        $export_opts .= ',';
                    }
                    $export_opts .= 'sync';
                }
                push @entries, "$host($export_opts)";
            }

            # Only actually write the line if there was at least one
            # valid host/option entry.
            if (@entries) {
                $contents .= "$path ".join(' ',@entries)."\n";
            }
        }
    }

    # Now just create the new configuration file.  Be careful to save
    # a backup of the previous file if necessary.
    my $result = LC::Check::file($EXPORTS,
                                 backup => ".old",
                                 contents => $contents,
        );
    $self->log("$EXPORTS created/updated") if $result;

    return $result;
}


sub fstab
{
    my ($self, $nfs_config) = @_;

    # Collect information for fstab file.
    my $contents = "# File generated by ncm-nfs on " .
        localtime() . ".\n";
    $contents .= "# Only nfs file systems managed by ncm-nfs component.\n";

    # Extract fstab information from existing file.
    my %oldnfs;
    my @oldnfs_order = ();
    open FSTAB, "<$FSTAB";
    while (<FSTAB>) {
        if (m/^\s*$/ or m/^\s*\#/) {
            # Keep blank lines or comments in the output file, although
            # leave out anything with the component name in it to avoid
            # ever growing file.
            if (! m/^\s*\#.*ncm-nfs.*/) {
                $contents .= $_;
            }
        } else {
            my ($device,$mntpt,$fstype,$opt,$freq,$passno) = split;
            $opt = "defaults" unless $opt;
            $freq = 0 unless defined($freq);
            $passno = 0 unless defined($passno);

            if ( ($fstype =~ /^(nfs4?|panfs)$/) || (($fstype eq 'none') && ($opt eq 'bind')) ) {
                # It is an nfs entry, save the information.
                $oldnfs{$device} = {
                    "device" => $device,
                    "mntpt" => $mntpt,
                    "fstype" => $fstype,
                    "opt" => $opt,
                    "freq" => $freq,
                    "passno" => $passno,
                };
                push(@oldnfs_order, $device);
            } else {
                # If the fstype doesn't begin with nfs (i.e. nfs or nfs4),
                # then just add the line to the output.
                $contents .= $_;
            }
        }
    }
    close FSTAB;

    # Now check the information given in the configuration.  Make sure
    # that the configuration is preserved.
    my %newnfs;
    my @newnfs_order = ();

    if ( $nfs_config->{'mounts'} ) {
        my $mounts = $nfs_config->{'mounts'};

        # Loop through all of the servers creating a line for each.
        for my $mount (@{$mounts}) {
            my $device = $mount->{'device'};
            my $mntpoint = $mount->{'mountpoint'};
            my $fstype = $mount->{'fstype'};
            my $options;
            if ( $mount->{'options'} ) {
                $options = $mount->{'options'};
            } else {
                $options = "defaults";
            }
            my $freq;
            if ( $mount->{'freq'} ) {
                $freq = $mount->{'freq'};
            } else {
                $freq = 0;
            }

            my $passno;
            if ( $mount->{'passno'} ) {
                $passno = $mount->{'passno'};
            } else {
                $passno = 0;
            }

            #store the device order
            push(@newnfs_order,$device);

            # Add the entry.
            $newnfs{$device} = {
                "device" => $device,
                "mntpt" => $mntpoint,
                "fstype" => $fstype,
                "opt" => $options,
                "freq" => $freq,
                "passno" => $passno,
                "action" => 0
            };
        }
    }

    # Add to the configuration file the new NFS locations.  Creating
    # the new mount points as necessary.  At the same time determine
    # what action will need to be taken (none, mount, unmount/mount,
    # or remount).
    foreach ( @newnfs_order ) {
        # Extract the entry from the hash.
        my $hashref = $newnfs{$_};
        my %hash = %$hashref;

        $contents .=
            $hash{device} . ' ' .
            $hash{mntpt} . ' ' .
            $hash{fstype} . ' ' .
            $hash{opt} . ' ' .
            $hash{freq} . ' ' .
            $hash{passno} . "\n";

        # If the directory doesn't exist, then create it.  Issue a
        # warning if this couldn't be done.
        my $mntpt = $hash{mntpt};
        mkpath($mntpt,0,0755) unless (-e $mntpt);
        unless (-d $mntpt) {
            $self->warn("error creating mountpoint $mntpt");
        }

        # Check matching entry in oldnfs.
        if (! defined($oldnfs{$_})) {
            $hashref->{action} = 'mount';
        } else {
            my $flag = compare_entries($hashref, $oldnfs{$_});
            if ($flag == 0) {
                $hashref->{action} = 'none';
            } elsif ($flag == 1) {
                $hashref->{action} = 'umount/mount';
            } else {
                $hashref->{action} = 'remount';
            }
        }
    }

    # Now just create the new configuration file.  Be careful to save
    # a backup of the previous file if necessary.
    my $result = LC::Check::file($FSTAB,
                                 backup => ".old",
                                 contents => $contents,
        );
    $self->log("$FSTAB created/updated") if $result;

    return $result, \%oldnfs, \@oldnfs_order, \%newnfs, \@newnfs_order;
}

# Given the nfs config, determine the new and old nfs mounts
# and do the appropriate unmounting/mounting
sub process_mounts
{
    my ($self, $nfs_config) = @_;

    my ($fstab_changed, $oldnfs, $oldnfs_order, $newnfs, $newnfs_order) = $self->fstab($nfs_config);

    # Process mount points and update /etc/fstab #


    # Unmount the file systems which are going away.   Do the unmounting
    # in the reverse order that the file systems are defined.
    foreach ( reverse @$oldnfs_order ) {
        my $hashref = $oldnfs->{$_};
        my $mntpt = $hashref->{mntpt};

        my $nref = $newnfs->{$_};

        # Unmount volume ONLY if new entry doesn't exist or the
        # mount point has changed.
        if (!defined($nref) || ($nref->{action} eq 'umount/mount') ) {
            $self->log("Unmounting $mntpt\n");
            system("umount -l $mntpt");
            if ($?) {
                $self->warn("Error unmounting $mntpt\n");
            } else {
                # Try removing mount point, giving warning on error.
                unless (rmdir $mntpt) {
                    $self->warn("can't delete mountpoint $mntpt");
                }
            }
        }
    }

    # Mount, unmount/mount, or remount as appropriate.
    foreach ( @$newnfs_order ) {
        # Entry from the current configuration.
        my $hashref = $newnfs->{$_};

        # Extract the mountpoint and the action.
        my $mntpt = $hashref->{mntpt};
        my $action = $hashref->{action};

        # Perform the necessary action.
        if (($action eq 'mount') || ($action eq 'umount/mount')) {
            $self->log("Mounting $mntpt\n");
            system("mount $mntpt");
            $self->warn("Error mounting $mntpt\n") if ($?);
        } elsif ($action eq 'remount') {
            $self->log("Remounting $mntpt\n");
            system("mount -o remount $mntpt");
            $self->warn("Error remounting $mntpt\n") if ($?);
        } else {
            $self->log("No action needed for $mntpt\n");
        }
    }

    return $fstab_changed;
}

sub Configure
{
    my ($self, $config) = @_;

    # Load ncm-nfs configuration into a hash
    my $nfs_config = $config->getTree($self->prefix());

    my $e_result = $self->exports($nfs_config);
    my $f_result = $self->process_mounts($nfs_config);

    # Force a reload of the nfs daemon.
    $self->log("Forcing nfs reload\n");
    system("service nfs reload");
    if ($?) {
        $self->warn("Error on nfs reload\n");
    }

    return 1;
}


1;      # Required for PERL modules
