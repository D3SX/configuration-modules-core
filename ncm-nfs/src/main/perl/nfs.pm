# ${license-info}
# ${developer-info}
# ${author-info}

package NCM::Component::nfs;

use strict;
use warnings;

use NCM::Component;
use vars qw(@ISA $EC);
@ISA = qw(NCM::Component);
$EC=LC::Exception::Context->new->will_store_all;

use File::Path qw(mkpath);

use CAF::Object qw(SUCCESS);
use CAF::FileWriter;
use CAF::FileReader;
use CAF::Service;

use EDG::WP4::CCM::Element qw(unescape);

use Readonly;

our $NoActionSupported = 1;

# The absolute names of configuration files.
Readonly my $EXPORTS => "/etc/exports";
Readonly my $FSTAB => "/etc/fstab";

Readonly my $EXPORTS_DEFAULT_SYNC => 'sync';

Readonly my $FSTAB_ACTION => 'action';

Readonly my $FSTAB_DEVICE => 'device';
Readonly my $FSTAB_MOUNTPOINT => 'mountpoint';
Readonly my $FSTAB_FSTYPE => 'fstype';
Readonly my $FSTAB_OPTIONS => 'options';
Readonly my $FSTAB_FREQ => 'freq';
Readonly my $FSTAB_PASSNO => 'passno';

Readonly::Array my @FSTAB_LINE => (
    $FSTAB_DEVICE, $FSTAB_MOUNTPOINT, $FSTAB_FSTYPE,
    $FSTAB_OPTIONS, $FSTAB_FREQ, $FSTAB_PASSNO,
);

Readonly::Hash my %FSTAB_DEFAULT => {
    $FSTAB_OPTIONS => 'defaults',
    $FSTAB_FREQ => 0,
    $FSTAB_PASSNO => 0,
};

Readonly my $FSTAB_ACTION_NONE => 'none';
Readonly my $FSTAB_ACTION_MOUNT => 'mount';
Readonly my $FSTAB_ACTION_REMOUNT => 'remount';
Readonly my $FSTAB_ACTION_UMOUNT_MOUNT => 'umount/mount';

Readonly::Array my @CMD_UMOUNT_LAZY => qw(umount -l);
Readonly::Array my @CMD_MOUNT => qw(mount);
Readonly::Array my @CMD_REMOUNT => qw(mount -o remount);

# Compares two fstab entries C<new> and C<old> for equality,
# and return action to be taken.
# If old does not exist, mount.
# If equal, do nothing.
# If the entries differ in the devices or mountpoint, do unmount/mount.
# Otherwise, remount.
# This is a function, not a method.
sub mount_action_new_old
{
    my ($new, $old) = @_;

    return $FSTAB_ACTION_MOUNT if (! $old);

    # Can numeric 'A != B' be different than 'A ne B' ?
    my $ne = sub {
        my $attr = shift;
        return $new->{$attr} ne $old->{$attr};
    };

    return $FSTAB_ACTION_UMOUNT_MOUNT if (&$ne($FSTAB_DEVICE) || &$ne($FSTAB_MOUNTPOINT));

    return $FSTAB_ACTION_REMOUNT if (&$ne($FSTAB_FSTYPE) || &$ne($FSTAB_OPTIONS) ||
                                     &$ne($FSTAB_FREQ) || &$ne($FSTAB_PASSNO));

    # Got the end, so hashes must be equal.
    return $FSTAB_ACTION_NONE;
}


sub exports
{
    my ($self, $tree) = @_;

    # Now just create the new configuration file.  Be careful to save
    # a backup of the previous file if necessary.
    my $fh = CAF::FileWriter->new($EXPORTS, backup => ".old", log => $self);

    # No timestamp anymore, otherwsie file changes trivially
    print $fh "#\n# File generated by ncm-nfs\n#\n";

    # Process exports to build /etc/exports

    my $exports = $tree->{exports};
    if ($exports) {
        # Pull out the parameters from the configuration.

        # Loop through all of the servers creating a line for each.
        foreach my $export (@{$exports}) {
            my $hosts = $export->{hosts};

            my @entries;
            foreach my $host_e (sort keys %$hosts) {
                my $host = unescape($host_e);
                my @export_opts = split(',', $hosts->{$host_e});

                # add option 'sync if neither 'sync', nor 'async' has been specified
                push(@export_opts, $EXPORTS_DEFAULT_SYNC) if ( ! grep {$_ =~ m/sync/} @export_opts);

                push(@entries, "$host(".join(',', @export_opts).")");
            }

            # Only actually write the line if there was at least one
            # valid host/option entry.
            if (@entries) {
                print $fh "$export->{path} ".join(' ', @entries)."\n";
            }
        }
    } else {
        $self->verbose("No exports defined");
        print $fh "# No exports defined\n";
    }

    my $result = $fh->close();
    if ($result) {
        $self->info("$EXPORTS created/updated");
    } else {
        $self->verbose("$EXPORTS unmodified");
    }

    return $result;
}


# Function given a fstab hashref, add defaults for the undefined values
# Returns a copy of the original hashref
sub fstab_add_defaults
{
    my $fstab = shift;

    # Use default values if undefined
    my %res = map {$_ => defined($fstab->{$_}) ?
                       $fstab->{$_} :
                       $FSTAB_DEFAULT{$_}} @FSTAB_LINE;

    return \%res;
};


# Function that parses an fstab line in a hasref
# Returns undef when the line is comment/empty
# Defaults are set
sub parse_fstab_line
{
    my $line = shift;
    chomp($line);

    # Comment/empty line
    return if ($line =~ m/^\s*(#.*)?$/);

    my %fstab;

    # Split and map the line using hashslice
    @fstab{@FSTAB_LINE} = split(/\s+/, $line);

    return fstab_add_defaults(\%fstab);
};


sub fstab
{
    my ($self, $tree) = @_;

    # Now just create the new configuration file.  Be careful to save
    # a backup of the previous file if necessary.
    my $fh_old = CAF::FileReader->new($FSTAB, log => $self);
    my @fstab_lines = split("\n", "$fh_old");

    my $fh = CAF::FileWriter->new($FSTAB, backup => ".old", log => $self);

    # Keep updated with filter below
    my $mngd_by = "nfs/nfs4/panfs filesystems and bind mounts";

    # Collect information for fstab file.
    print $fh "# File edited by ncm-nfs\n";
    print $fh "# Only $mngd_by managed by ncm-nfs component.\n";

    # Extract fstab information from existing file.
    my %old;
    my @old_order;
    foreach my $line (@fstab_lines) {
        # line does not end in newline (see split above)
        my $fstab = parse_fstab_line($line);
        if ($fstab) {
            if ( ($fstab->{$FSTAB_FSTYPE} =~ m/^(nfs4?|panfs)$/) ||
                 (($fstab->{$FSTAB_FSTYPE} eq 'none') && ($fstab->{$FSTAB_OPTIONS} eq 'bind')) ) {
                # It is an ncm-nfs managed entry, save the information.
                $old{$fstab->{$FSTAB_DEVICE}} = $fstab;
                push(@old_order, $fstab->{$FSTAB_DEVICE});
            } else {
                # fstab entry not under ncm-nfs control; add the line as is.
                print $fh $line, "\n";
            }
        } else {
            # Keep blank lines or comments in the output file, although
            # leave out anything with the component name in it to avoid
            # ever growing file.
            print $fh $line, "\n" if ($line !~ m/ncm-nfs/);
        };
    }

    # Now check the information given in the configuration.  Make sure
    # that the configuration is preserved.
    my %new;
    my @new_order;

    my $mounts = $tree->{mounts};
    if ( $mounts ) {
        # Loop through all of the servers creating a line for each.
        foreach my $mount (@$mounts) {
            my $device = $mount->{$FSTAB_DEVICE};
            # store the device order

            push(@new_order, $device);

            $new{$device} = fstab_add_defaults($mount);
        }
    } else {
        $self->verbose("No mounts configured");
    }

    # Add to the configuration file the new NFS locations, creating
    # the new mount points as necessary. At the same time determine
    # what action will need to be taken (none, mount, unmount/mount,
    # or remount).
    foreach my $device ( @new_order ) {
        print $fh join(' ', map {$new{$device}->{$_}} @FSTAB_LINE)."\n";

        # If the directory doesn't exist, then create it.
        # Issue a warning if this couldn't be done.
        my $mntpt = $new{$device}->{$FSTAB_MOUNTPOINT};
        if (! -d $mntpt) {
            local $@;
            eval { mkpath($mntpt, 0, 0755) } unless (-e $mntpt);
            if ($@) {
                $self->error("Failed to create mountpoint $mntpt: $@");
            } elsif (! -d $mntpt) {
                $self->warn("Failed to create mountpoint $mntpt");
            }
        }

        $new{$device}->{$FSTAB_ACTION} = mount_action_new_old($new{$device}, $old{$device});
    }

    my $result = $fh->close();
    if ($result) {
        $self->info("$FSTAB created/updated");
    } else {
        $self->verbose("$FSTAB unmodified");
    }

    return $result, \%old, \@old_order, \%new, \@new_order;
}


# Do something mount(point) related (umount, mount, remount, ...)
# C<$cmd> is the arrayref, the mountpoint is appended
# Returns SUCCESS on success, undef on failure.
sub do_mount
{
    my ($self, $cmd, $fstab) = @_;

    my $proc = CAF::Process->new($cmd, log => $self);
    $proc->pushargs($fstab->{$FSTAB_MOUNTPOINT});
    $proc->execute();
    if ($?) {
        $self->warn("Error unmounting ", $fstab->{$FSTAB_MOUNTPOINT},
                    " (device ", $fstab->{$FSTAB_DEVICE}, ", cmd $proc)");
        return;
    } else {
        return SUCCESS;
    }
}


# Given the ncm-nfs config, determine the new and old ncm-nfs managed mounts
# and do the appropriate unmounting/mounting
sub process_mounts
{
    my ($self, $tree) = @_;

    my ($fstab_changed, $old, $old_order, $new, $new_order) = $self->fstab($tree);

    # Unmount the file systems which are going away.
    # Unmount in the reverse order that the file systems are defined.
    my $action_taken = 0;

    foreach my $device ( reverse @$old_order ) {
        # Unmount volume ONLY if new entry doesn't exist or the
        # mount point has changed.
        if (! defined($new->{$device}) ||
            ($new->{$device}->{$FSTAB_ACTION} eq $FSTAB_ACTION_UMOUNT_MOUNT) ) {
            $action_taken = 1;
            if ($self->do_mount(\@CMD_UMOUNT_LAZY, $old->{$device})) {
                my $mntpt = $old->{$device}->{$FSTAB_MOUNTPOINT};
                # Try removing mount point, giving warning on error.
                unless (rmdir $mntpt) {
                    $self->warn("cannot delete mountpoint $mntpt: $!");
                }
            }
        }
    }

    # Mount or remount as appropriate.
    foreach my $device ( @$new_order ) {
        my $action = $new->{$device}->{$FSTAB_ACTION};

        # Perform the necessary action.
        if (($action eq $FSTAB_ACTION_MOUNT) ||
            ($action eq $FSTAB_ACTION_UMOUNT_MOUNT)) {
            $action_taken = 1;
            $self->do_mount(\@CMD_MOUNT, $new->{$device})
        } elsif ($action eq $FSTAB_ACTION_REMOUNT) {
            $action_taken = 1;
            $self->do_mount(\@CMD_REMOUNT, $new->{$device})
        } else {
            $self->verbose("No action needed for ", $new->{$device}->{$FSTAB_MOUNTPOINT});
        }
    }

    return $fstab_changed, $action_taken;
}

sub Configure
{
    my ($self, $config) = @_;

    # Load ncm-nfs configuration into a hash
    my $tree = $config->getTree($self->prefix());

    my $e_result = $self->exports($tree);
    my ($f_result, $action_taken) = $self->process_mounts($tree);

    if ($e_result || $f_result || $action_taken) {
        # Force a reload of the nfs daemon.
        $self->info("Forcing nfs reload");
        # report error on failure
        CAF::Service->new("nfs", log => $self)->reload();
    };

    return 1;
}


1;      # Required for PERL modules
