use strict;
use warnings;
use Test::More;
use Test::MockModule;
use Test::Quattor qw(configure);
use CAF::Object;
use NCM::Component::postgresql;

use Test::Quattor::TextRender::Base;

$CAF::Object::NoAction = 1;

my $caf_trd = mock_textrender();

# service variant set to linux_sysv

set_caf_file_close_diff(1);

my $cmp = NCM::Component::postgresql->new("postgresql");
my $cfg = get_config_for_profile('configure');

my $mock = Test::MockModule->new('NCM::Component::postgresql');

my $expected_fns = [qw(/not/a/file)];
$mock->mock('_file_exists', sub {
    shift;
    my $filename = shift;
    return grep {$_ eq $filename} @$expected_fns;
});

# whoami is tested elsewhere
set_desired_output('/usr/pgsql-9.2/bin/postmaster --version', "postgres (PostgreSQL) 9.2.13\n");
my $iam = $cmp->whoami($cfg);

=head1 constants

=cut

is_deeply({ %NCM::Component::postgresql::MAIN_CONFIG }, {
    NAME => 'main',
    TT => 'main_config',
    CONFIG => '/config/main',
    CONFIG_EL => '/config/main',
    FILENAME => 'postgresql.conf',
    TEXT => 'postgresql_conf',
}, 'MAIN_CONFIG as expected');


is_deeply({ %NCM::Component::postgresql::HBA_CONFIG }, {
    NAME => 'hba',
    TT => 'hba_config',
    CONFIG => '/config/hba',
    CONFIG_EL => '/config',
    FILENAME => 'pg_hba.conf',
    TEXT => 'pg_hba',
}, "HBA_CONFIG as expected");

is_deeply({ %NCM::Component::postgresql::PG_ALTER }, {
    NAME => 'pg_alter',
    TT => 'pg_alter',
    CONFIG => '/roles',
    CONFIG_HASHREF => undef,
}, "PG_ALTER as expected");

=item create_postgresql_config

=cut

diag explain $iam;
my $fh;

is($cmp->create_postgresql_config($cfg, $iam, %NCM::Component::postgresql::MAIN_CONFIG),
   1, 'create_postgresql_config returns changed state for MAIN_CONFIG');
$fh = get_file($iam->{pg}->{data}."/".$NCM::Component::postgresql::MAIN_CONFIG{FILENAME});
isa_ok($fh, "CAF::FileWriter", 'create_postgresql_config creates filewriter instance for MAIN_CONFIG');
is("$fh", "\narchive_command = 'main archive'\n", "content with TT from main config for MAIN_CONFIG");

is($cmp->create_postgresql_config($cfg, $iam, %NCM::Component::postgresql::HBA_CONFIG),
   1, 'create_postgresql_config returns changed state for HBA_CONFIG');
$fh = get_file($iam->{pg}->{data}."/".$NCM::Component::postgresql::HBA_CONFIG{FILENAME});
isa_ok($fh, "CAF::FileWriter", 'create_postgresql_config creates filewriter instance for HBA_CONFIG');
is("$fh", "pg_hba plain text", "content from text for HBA_CONFIG");

my $pg_alter = { %NCM::Component::postgresql::PG_ALTER };
$pg_alter->{FILENAME} = "pgalter_fn";
$pg_alter->{CONFIG_HASHREF} = {a => 'b', c => 'd'};
is($cmp->create_postgresql_config($cfg, $iam, %$pg_alter),
   1, 'create_postgresql_config returns changed state for PG_ALTER');
$fh = get_file($iam->{pg}->{data}."/".$pg_alter->{FILENAME});
isa_ok($fh, "CAF::FileWriter", 'create_postgresql_config creates filewriter instance for PG_ALTER');
is("$fh", "## Generated by ncm-postgresql\n## DO NOT EDIT\na=b\nc=d\n",
   "content from TT and CONFIG_HASHREF for PG_ALTER");

=head1 initdb

=cut

# initdb will stop and end with stopped service
# so for sake of simplicity, have the service not running to start with
# not running (1=bash fail)
set_command_status('service myownpostgresql status', 1);

my $setupfile = "$iam->{pg}->{engine}/postgresql$iam->{exesuffix}-setup";
$expected_fns = [$setupfile];
command_history_reset();
ok($cmp->initdb($iam), "initdb returns success with setup file");
ok(command_history_ok([
       qr{service myownpostgresql status},
       qr{/usr/pgsql-9.2/bin/postgresql123-setup initdb},
       qr{service myownpostgresql status},
]), "expected commands ran by initdb with setupfile");

# no setup file, but version is recent enough
$expected_fns = [];
command_history_reset();
ok($cmp->initdb($iam), "initdb returns success with setup file");
ok(command_history_ok([
       qr{service myownpostgresql status},
       qr{service myownpostgresql initdb},
       qr{service myownpostgresql status},
]), "expected commands ran by initdb without setupfile but recent service");

my $iam2 = { %$iam };
$iam2->{version} = [8, 1, 0];
command_history_reset();
# start fails because status is always off
ok(! defined($cmp->initdb($iam2)), "initdb with old version returns undef in case of failure to start");
ok(command_history_ok([
       qr{service myownpostgresql status},
       qr{service myownpostgresql start},
       qr{service myownpostgresql status},
]), "expected commands ran by initdb without setupfile and old service");



done_testing();
