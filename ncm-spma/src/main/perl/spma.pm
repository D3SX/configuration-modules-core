# ${license-info}
# ${developer-info}
# ${author-info}

#
# spma component - NCM SPMA configuration component
#
# generates the SPMA configuration file, runs SPMA if required.
#
################################################################################

package NCM::Component::spma;
#
# a few standard statements, mandatory for all components
#
use strict;
use parent 'NCM::Component';
our $EC=LC::Exception::Context->new->will_store_all;

use EDG::WP4::CCM::Element qw(unescape);

use CAF::Process;
use CAF::FileWriter;
use LC::Exception qw(SUCCESS);
use Set::Scalar;
use File::Path qw(mkpath);
use Readonly;

Readonly my $REPOS_DIR => "/etc/yum.repos.d";
Readonly my $REPOS_TEMPLATE => "spma/repository.tt";
Readonly my $REPOS_TREE => "/software/repositories";
Readonly my $PKGS_TREE => "/software/packages";
Readonly my $CMP_TREE => "/software/components/${project.artifactId}";

our $NoActionSupported = 1;

# Removes any repositories present in the system that are not listed in
# $allowed_repos.
sub cleanup_old_repos
{
    my ($self, $repo_dir, $allowed_repos) = @_;

    my $dir;
    if (!opendir($dir, $repo_dir)) {
	$self->error("Unable to read repositories in $repo_dir");
	return 0;
    }

    my $current = Set::Scalar->new(map(m{(.*)\.repo$}, readdir($dir)));

    closedir($dir);
    my $allowed = Set::Scalar->new(map($_->{name}, @$allowed_repos));
    my $rm = $current-$allowed;
    foreach my $i (@$rm) {
	# We use $f here to make Devel::Cover happy
	my $f = "$repo_dir/$i.repo";
	$self->verbose("Unlinking outdated repository $f");
	if (!unlink($f)) {
	    $self->error("Unable to remove outdated repository $i: $!");
	    return 0;
	}
    }
    return 1;
}

# Creates the repository dir if needed.
sub initialize_repos_dir
{
    my ($self, $repo_dir) = @_;
    if (! -d $repo_dir) {
	$self->verbose("$repo_dir didn't exist. Creating it");
	if (!eval{mkpath($repo_dir)} || $@) {
	    $self->error("Unable to create repository dir $repo_dir: $@");
	    return 0;
	}
    }
    return 1;
}

# Generates the repository files in $repos_dir based on the contents
# of the $repos subtree. It uses Template::Toolkit $template to render
# the file. Optionally, proxy information will be used. In that case,
# it will use the $proxy host, wich is of $type "reverse" or
# "forward", and runs on the given $port.
sub generate_repos
{
    my ($self, $repos_dir, $repos, $template, $proxy, $type, $port) = @_;

    $proxy .= ":$port" if defined($port);

    foreach my $repo (@$repos) {
	my $fh = CAF::FileWriter->new("$repos_dir/$repo->{name}.repo",
				      log => $self);
	print $fh "# File generated by ", __PACKAGE__, ". Do not edit\n";
	# Only reverse proxies are handled here. Forward proxies
	# should be specified in /etc/yum.conf, in the proxyhost=
	# field.
	if ($proxy && ($type eq 'reverse')) {
	    $repo->{protocols}->[0]->{url} =~ s{^(.*?)://[^/]+(/?)}{$1://$proxy$2};
	}
	if (!$self->template()->process($template, $repo, $fh)) {
	    $self->error ("Unable to generate repository $repo->{name}: ",
			  $self->template()->error());
	    $fh->cancel();
	    return 0;
	}
	$fh->close();
    }

    return 1;
}



sub Configure
{
    my ($self, $config) = @_;

    my $repos = $config->getElement($REPOS_TREE)->getTree();
    my $t = $config->getElement($CMP_TREE)->getTree();
    my $pkgs = $config->getElement($PKGS_TREE)->getTree();
    $self->initialize_repos_dir($REPOS_DIR) or return 0;
    $self->generate_repos($REPOS_DIR, $repos, $REPOS_TEMPLATE, $t->{proxyhost},
			  $t->{proxytype}, $t->{proxyport}) or return 0;
    $self->update_pkgs($pkgs, $t->{run_spma} eq 'yes', $t->{userpkgs} eq 'yes')
      or return 0;
    return 1;
}
1; # required for Perl modules
