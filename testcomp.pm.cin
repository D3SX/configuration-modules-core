###############################################################################
# This is '@SELF@', a @NAME@'s file
###############################################################################
#
# VERSION:    @VERSION@-@RELEASE@, @DATE@
# AUTHOR:     @AUTHOR@
# MAINTAINER: @MAINTAINER@
# LICENSE:    @LICENSE@
#
###############################################################################
# Coding style: emulate <TAB> characters with 4 spaces, thanks!
###############################################################################
#
# Example NCM Component with NVA API config access
#
###############################################################################

package NCM::Component::testcomp;
#
# a few standard statements, mandatory for all components
#

use strict;
use NCM::Component;
use vars qw(@ISA $EC);
@ISA = qw(NCM::Component);
$EC=LC::Exception::Context->new->will_store_all;


use EDG::WP4::CCM::Element;

# search function: dumps the config tree recursively
# code adapted from Rafael A. Leiva

my $depth;

sub search {
    my ($self,$element) = @_;
    my $tree = $element->getTree();
    my $path = $element->getPath();
    my $i;
    my $str='';

    # We usually don't need this, as the developer knows beforehand
    # what the data type for any given path is. This is just an
    # automatic and blind way of traversing the first level of a
    # subtree.
    if (ref($tree) eq 'HASH') {
	$str = "The element at $path is a nlist\n";
	while (my ($k, $v) = each(%$tree)) {
	    if (!ref($v)) {
		$str .= "Sub-element $k is an scalar (property) with ".
		    "value: $v\n";
	    } elsif (ref($v) eq 'ARRAY') {
		$str .= "Sub-element $k is a list with " . scalar(@$v) .
		    "elements";
	    } elsif (ref($v) eq 'HASH') {
		$str .= "Sub-element $k is a nlist with the following keys: " .
		    join(", ", keys(%$v)) . "\n";
	    }
	}
    } elsif (ref($tree) eq 'ARRAY') {
	$str = "The element at $path is a list\n";
	foreach $i (@$tree) {
	    if (!ref($i)) {
		$str .= "Sub-element is an scalar (property) with value: $i\n";
	    } elsif (ref($i) eq 'ARRAY') {
		$str .= "Sub-element is a list with " . scalar(@$v) .
		    "elements";
	    } elsif (ref($i) eq 'HASH') {
		$str .= "Sub-element is a nlist with the following keys: " .
		    join(", ", keys(%$i)) . "\n";
	    }
	}
    } else {
	$str = "The element at $path is a simple property with value $tree\n";
    }
}

##########################################################################
sub Configure($$) {
##########################################################################
  my ($self,$config)=@_;

  $self->info("hello node");

  if ($NoAction) {
    $self->info("I am running in fake mode (noaction)");
  }

  $self->warn("this is a fake warning");

  $self->info("now dumping the first level of the config tree on /system:");

  my $element = $config->getElement('/system');
  $depth=0;
  $self->search($element);

  $self->OK("everything is fine, as this component doesn't do anything anyway");

  $self->error("I can even pretend there are errors");

  return; # return code is not checked.

}

1; # Perl module requirement.
